#!/usr/bin/python
# -*- coding: utf-8; -*-
#
# (c) 2010 Mandriva, http://www.mandriva.com
#
# $Id$
#
# This file is part of Pulse 2, http://pulse2.mandriva.org
#
# Pulse 2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Pulse 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
#

"""
    This is a generic hook skeleton to be used with pulse 2 imaging server
"""
import sys
import re
import os.path
import twisted.internet.reactor
import logging
import logging.config
import pulse2.apis.clients.imaging
import pulse2.imaging_server.config

CONFIG_FILE = '/etc/mmc/pulse2/imaging-server/imaging-server.ini' #: config file location

# default error code
ERROR_OK = 0        #: no error
ERROR_SERVER = 1    #: error server-side
ERROR_CLIENT = 2    #: error client-side (here)
ERROR_UNKNOWN = 3   #: unknow (and default) error
exitcode = ERROR_UNKNOWN #: global error code, used when exiting

########################################################################
#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
########################################################################

def myCall():
    """
        Design your own call here

        a deferred should be passed to callFunction()
        @woot
    """
    global exitcode

    mac = '' # client MAC address
    filename = '' # where the inventory is temporaly stored
    filestream = None
    inventory = {} # will hold our inventory

    if len(sys.argv) != 3: # not enough (or too much) args
        logging.getLogger().error('HOOK %s : I was not called with the right number of arguments (two expected, got %d)' % (sys.argv[0], len(sys.argv) - 1))
        exitcode = ERROR_CLIENT
        endBack()

    mac = sys.argv[1]

    if not pulse2.utils.isMACAddress(mac):
        logging.getLogger().error('HOOK %s : First arg (%s) do not seems to be a MAC address' % (sys.argv[0], mac))
        exitcode = ERROR_CLIENT
        endBack()

    filename = sys.argv[2]

    if not os.path.isfile(filename):
        logging.getLogger().error('HOOK %s : Second arg (%s) do not seems to be an existing file name' % (sys.argv[0], filename))
        exitcode = ERROR_CLIENT
        endBack()

    try :
        filestream = open(filename)
    except:
        logging.getLogger().error('HOOK %s : Can\'t read %s, giving up' % (sys.argv[0], filename))
        exitcode = ERROR_CLIENT
        endBack()

    mem_info    = {'lower' : 0, 'upper': 0}
    MEM_INFO_RE = re.compile("^M:([0-9a-f]+),U:([0-9a-f]+)$") # lower / upper mem
    bus_info    = {}
    BUS_INFO_RE = re.compile("^B:([0-9A-Fa-f]+),f:([0-9A-Fa-f]+),v:([0-9A-Fa-f]+),d:([0-9A-Fa-f]+),c:([0-9A-Fa-f]+),s:([0-9A-Fa-f]+)$") # bus, dev, vendor, device, class, subclass
    disk_info   = {}
    DISKINFO_RE = re.compile("^D:\(hd([0-9]+)\):CHS\(([0-9]+),([0-9]+),([0-9]+)\)=([0-9]+)$") # number, CHS, size
    PARTINFO_RE = re.compile("^P:([0-9]+),t:([0-9a-f]+),s:([0-9]+),l:([0-9]+)$") # number, type, start, len
    BIOSINFO_RE = re.compile("^S0:([^\|]*)\|([^\|]*)\|([^\|]*)$") # 3 components : vendor, version, date
    bios_info   = {'vendor': '', 'version': '', 'date' : ''}
    SYSINFO_RE  = re.compile("^S1:([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|([0-9A-F]{32})$") # 5 components : vendor, desc, ??, ??, UUID (16 hex chars)
    sys_info    = {'manufacturer': '', 'product': '', 'version' : '', 'serial' : '', 'uuid' : ''}
    ENCLOS_RE   = re.compile("^S3:([^\|]*)\|([0-9]+)$") # vendor, type
    enclos_info = {'vendor': '', 'type': ''}
    MEMSLOT_RE  = re.compile("^SM:([0-9]+):([0-9]+):([^:]*):([0-9]+):([0-9]+)$") # Size in MB, Form factor, Location, Type, Speed in MHZ
    memslot_info= { 'size' : 0, 'ff': 0, 'location': '', 'type': '', 'speed': 0 }
    NUMCPU_RE   = re.compile("^S4:([0-9]+)$") # CPU number
    numcpu_info = 0
    FEATCPU_RE  = re.compile("^C:(.*)$") # CPU features, comma-separated
    featcpu_info= []
    FREQCPU_RE  = re.compile("^F:([0-9]+)$") # CPU frequency
    freqcpu_info= []
    MACADDR_RE  = re.compile("^MAC Address:(.+)$") # MAC Address
    macaddr_info= ''
    IPADDR_RE  = re.compile("^IP Address:(.+):([0-9]+)$") # IP Address:port
    ipaddr_info= {'ip': '', 'port': 0}
    current_disk = None # track the disk we are reading
    for line in filestream:
        if not len(line):
            continue
        mo = re.match(MEM_INFO_RE, line)
        if mo :
            mem_info['lower'] = int(mo.group(1), 16)
            mem_info['upper'] = int(mo.group(2), 16)
            continue
        mo = re.match(BUS_INFO_RE, line)
        if mo :
            bus = int(mo.group(1), 16)
            dev = int(mo.group(2), 16)
            vendor = int(mo.group(3), 16)
            device = int(mo.group(4), 16)
            cl = int(mo.group(5), 16)
            subcl = int(mo.group(6), 16)
            if not bus in bus_info:
                bus_info[bus] = dict()
            bus_info[bus][dev] = {
                "vendor": vendor,
                "device" : device,
                "class" : cl,
                "subclass" : subcl
            }
            continue
        mo = re.match(DISKINFO_RE, line)
        if mo :
            num = int(mo.group(1), 10)
            c = int(mo.group(2), 10)
            h = int(mo.group(3), 10)
            s = int(mo.group(4), 10)
            sz = int(mo.group(4), 10)
            disk_info[num] = {
                "C": c,
                "H" : h,
                "S" : s,
                "size" : sz,
                "parts" : dict()
            }
            current_disk = num
            continue
        mo = re.match(PARTINFO_RE, line)
        if mo :
            num = int(mo.group(1), 10)
            t = int(mo.group(2), 16)
            s = int(mo.group(3), 10)
            l = int(mo.group(4), 10)
            disk_info[current_disk]['parts'][num] = {
                'type' : t,
                'start' : s,
                'length' : l
            }
            continue
        mo = re.match(BIOSINFO_RE, line)
        if mo :
            bios_info['vendor'] = mo.group(1)
            bios_info['version'] = mo.group(2)
            bios_info['date'] = mo.group(3)
            continue
        mo = re.match(SYSINFO_RE, line)
        if mo :
            sys_info['manufacturer'] = mo.group(1)
            sys_info['product'] = mo.group(2)
            sys_info['version'] = mo.group(3)
            sys_info['serial'] = mo.group(4)
            sys_info['uuid'] = mo.group(5)
            continue
        mo = re.match(ENCLOS_RE, line)
        if mo :
            enclos_info['vendor'] = mo.group(1)
            enclos_info['type'] = mo.group(2)
            continue
        mo = re.match(MEMSLOT_RE, line)
        if mo :
            memslot_info['size'] = int(mo.group(1), 10)
            memslot_info['ff'] = int(mo.group(2), 10)
            memslot_info['location'] = mo.group(3)
            memslot_info['type'] = mo.group(4)
            memslot_info['speed'] = int(mo.group(5), 10)
            continue
        mo = re.match(NUMCPU_RE, line)
        if mo :
            numcpu_info = int(mo.group(1), 10)
            continue
        mo = re.match(FEATCPU_RE, line)
        if mo :
            featcpu_info = map(lambda x: int(x, 16), mo.group(1).split(','))
            continue
        mo = re.match(FREQCPU_RE, line)
        if mo :
            freqcpu_info = int(mo.group(1), 10)
            continue
        mo = re.match(MACADDR_RE, line)
        if mo :
            macaddr_info = mo.group(1)
            continue
        mo = re.match(IPADDR_RE, line)
        if mo :
            ipaddr_info['ip'] = mo.group(1)
            ipaddr_info['port'] = int(mo.group(2), 10)
            print ipaddr_info
            continue
        logging.getLogger().warning('HOOK %s : unprocessed line %s' % (sys.argv[0], line))

    filestream.close()

    inventory = {
        'mem'       : mem_info,
        'bus'       : bus_info,
        'disk'      : disk_info,
        'bios'      : bios_info,
        'sys'       : sys_info,
        'enclos'    : enclos_info,
        'memslot'   : memslot_info,
        'numcpu'    : numcpu_info,
        'featcpu'   : featcpu_info,
        'freqcpu'   : freqcpu_info,
        'macaddr'   : macaddr_info,
        'ipaddr'    : ipaddr_info
    }

    try:
        callFunction(imagingAPI.processInventory(mac, inventory))
    except AttributeError, e:
        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
        exitcode = ERROR_CLIENT
        endBack()

def myTreatment(result):
    """
        Design your own treatment here

        don't forget to set exitcode and finally call endBack()
    """
    global exitcode
    if result and result != None:
        exitcode= ERROR_OK
        logging.getLogger().info('HOOK %s : SUCCESS !' % sys.argv[0])
    else:
        exitcode = ERROR_SERVER
        logging.getLogger().error('HOOK %s : Error server side !' % sys.argv[0])
    endBack()

########################################################################
#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
########################################################################

def endBack(when = None):
    """
        take the reactor down
    """
    if when == "timeout" :
        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)

def callBack(result):
    """
        XMLRPC result treatment

        check if it was a success by analysing result
        if it is a success, call myCall(result)
        if not, exitcode is set to ERROR_SERVER then call endBack()
    """

    global exitcode
    # if result is a list and the first arg a string and its value,
    # 'PULSE2_ERR', then something went wrong
    if type(result) == list and type(result[0]) == str and result[0] == 'PULSE2_ERR':
        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
        exitcode = ERROR_SERVER
        endBack()
    else:
        logging.getLogger().debug("%s : No error" % (sys.argv[0]))
        exitcode = ERROR_CLIENT
        myTreatment(result)

def errorBack(reason):
    """
        XMLRPC error treatment

        just set exitcode to ERROR_CLIENT then call endBack()
    """
    global exitcode
    exitcode = ERROR_CLIENT
    endBack()

def callFunction(deffered):
    """
        XMLRPC request handling

        attach callBack() and errorBack() to the deferred
    """
    deffered.addCallbacks( # deferred handling
        callBack,
        errorBack
    )

# Parse the command line
config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
config.setup(CONFIG_FILE)
logging.config.fileConfig(CONFIG_FILE)

# Instanciate the API
imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
    "server" : config.pserver_host,
    "port" : config.pserver_port,
    "mountpoint" : config.pserver_mount_point,
    "enablessl" : config.pserver_enablessl,
    "username" : config.pserver_username,
    "password" : config.pserver_password,
    "verifypeer" : config.pserver_verifypeer,
    "localcert" : config.pserver_localcert,
    "cacert" : config.pserver_cacert,
}) #: Object which will be used to speak with our pserver

# anti-blocking stuff
# I have 30 seconds to get my result or be killed
twisted.internet.reactor.callLater(10, endBack, "timeout")

# fire the reactor
twisted.internet.reactor.callWhenRunning(myCall)
twisted.internet.reactor.run()
sys.exit(exitcode)

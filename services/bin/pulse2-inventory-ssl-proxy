#!/usr/bin/python
# -*- coding: utf-8; -*-
#
# (c) 2007-2008 Mandriva, http://www.mandriva.com/
#
# $Id: __init__.py 22 2008-06-16 07:43:42Z cdelfosse $
#
# This file is part of Pulse 2, http://pulse2.mandriva.org
#
# Pulse 2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Pulse 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pulse 2; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

import os
import socket
import sys
import time
import logging
import signal

import BaseHTTPServer
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
from httplib import HTTPSConnection
import threading
from threading import Thread
import ConfigParser

class Singleton(object):
    def __new__(type):
        if not '_the_instance' in type.__dict__:
            type._the_instance = object.__new__(type)
        return type._the_instance

class Pulse2InventoryProxyConfig(Singleton):
    server = '192.168.100.106'
    port = 9999
    local_port = 9999
    path = '/'
    command_name = '/usr/local/bin/ocsinventory-agent'
    command_attr = '--server localhost:9999'
    enablessl = True
    key_file = "conf/key/privkey.pem"
    cert_file = "conf/key/cacert.pem"

    def setup(self, config_file = 'conf/p2ipc.ini'):
        # Load configuration file
        self.cp = ConfigParser.ConfigParser()
        self.cp.read(config_file)

        if self.cp.has_option('main', 'server'):
            self.server = self.cp.get('main', 'server')
        if self.cp.has_option('main', 'port'):
            self.port = self.cp.get('main', 'port')
        if self.cp.has_option('main', 'local_port'):
            self.port = self.cp.get('main', 'local_port')
        if self.cp.has_option('main', 'path'):
            self.path = self.cp.get('main', 'path')
        if self.cp.has_option('main', 'command_name'):
            self.command_name = self.cp.get('main', 'command_name')
        if self.cp.has_option('main', 'command_attr'):
            self.command_attr = self.cp.get('main', 'command_attr')
        if self.cp.has_option('main', 'enablessl'):
            self.enablessl = self.cp.getboolean('main', 'enablessl')
        if self.cp.has_option('main', 'key_file'):
            self.key_file = self.cp.get('main', 'key_file')
        if self.cp.has_option('main', 'cert_file'):
            self.cert_file = self.cp.get('main', 'cert_file')

class LaunchInv(Thread):
    def __init__(self, config):
        self.config = config
        self.command = '%s %s' % (self.config.command_name, self.config.command_attr)
        Thread.__init__(self)

    def inventory(self):
        return os.popen(self.command)

    def run(self):
        time.sleep(1)
        self.inventory()

class HttpInventoryProxySingleton(Singleton):
    count_call = 0
    want_quit = False
    def halt(self):
        self.want_quit = True

class HttpInventoryProxy(BaseHTTPServer.BaseHTTPRequestHandler):
    def __init__(self, *args):
        self.logger = logging.getLogger()
        self.config = Pulse2InventoryProxyConfig()
        self.singleton = HttpInventoryProxySingleton()
        BaseHTTPServer.BaseHTTPRequestHandler.__init__(self, *args)

    def log_message(self, format, *args):
        self.logger.info(format % args)

    def send(self, data):
        if self.config.enablessl:
            h = HTTPSConnection(self.config.server, self.config.port)
            h.key_file = self.config.key_file
            h.cert_file = self.config.cert_file
        else:
            h = HTTPConnection(self.config.server, self.config.port)
        try:
            h.request('POST', self.config.path, data, {'content-type':'application/x-compress'})
        except socket.error, e:
            if e.args == (111, 'Connection refused'):
                print "Connection refused"
            else:
                print e.args
            sys.exit(-1)
                
        return h.getresponse()

    def do_POST(self):
        content = self.rfile.read(int(self.headers['Content-Length']))
        cont = [content, self.headers['Content-Type']]
        resp = self.send(content)
        self.send_response(resp.status)
        self.end_headers()
        self.wfile.write(resp.read())
        self.singleton.count_call += 1
        if self.singleton.count_call > 1:
            self.singleton.halt()

def handler(signum, frame):
    """
    SIGTERM handler
    """
    os.seteuid(0)
    os.setegid(0)
    try:
        os.unlink(Pulse2InventoryProxyConfig().pidfile)
    except OSError:
        pass
    
    sys.exit(0)


Pulse2InventoryProxyConfig().setup()

signal.signal(signal.SIGTERM, handler)
signal.signal(signal.SIGINT, handler)

launchinv = LaunchInv(Pulse2InventoryProxyConfig())
launchinv.setDaemon(True)
launchinv.start()

httpd = HTTPServer(('', Pulse2InventoryProxyConfig().local_port), HttpInventoryProxy)

while not HttpInventoryProxySingleton().want_quit:
    httpd.handle_request()



#!/usr/bin/python
# -*- coding: utf-8; -*-
#
# (c) 2007-2008 Mandriva, http://www.mandriva.com/
#
# $Id$
#
# This file is part of Pulse 2, http://pulse2.mandriva.org
#
# Pulse 2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Pulse 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pulse 2; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

"""
    This is the Pulse2 launchers manager
    The goal is to provide a helper to run launchers:
    * start (fork)
    * stop (kill)
"""

import os
import os.path
import sys
import ConfigParser
import re
import logging
import logging.config
import optparse
import signal

from pulse2.launcher.config import LauncherConfig

def start_launcher(name, config):
    """
    daemonize a launcher
    """
    logger = logging.getLogger()
    logger.info('daemonization started: launcher "%s"' % name)

    pid_path = config.pid_path
    if not os.path.isdir(pid_path):
        os.makedirs(pid_path)

    pid_file = os.path.join(pid_path, '%s.pid' % name)
    launcher_path = config.launcher_path
    # Test if this launcher already exists
    if os.path.isfile(pid_file):
        logger.warning('failed to start launcher "%s": pid file "%s" already exist' % (name, pid_file))
        print ('failed to start launcher "%s": pid file "%s" already exist' % (name, pid_file))
        return

    # do the UNIX double-fork magic, see Stevens' "Advanced
    # Programming in the UNIX Environment" for details (ISBN 0201563177)
    try:
        pid = os.fork()
        if pid > 0:
            # first parent stays alive
            return True
    except OSError, error:
        logger.error('daemonization part #1 failed: %d (%s)' % (error.errno, error.strerror))
        print >> sys.stderr, "daemonization part #1 failed: %d (%s)" % (error.errno, error.strerror)
        sys.exit(1)

    # decouple from parent environment
    os.close(sys.stdin.fileno())
    os.close(sys.stdout.fileno())
    os.close(sys.stderr.fileno())
    os.chdir("/")
    os.setsid()

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent, print eventual PID before
            logger.info('daemonization succedeed: "%s", pid %d' % (name, pid) )
            os.seteuid(0)
            os.setegid(0)
            os.system("echo " + str(pid) + " > " + pid_file)
            sys.exit(0)
    except OSError, error:
        logger.error('daemonization part #2 failed: %d (%s)' % (error.errno, error.strerror))
        print >> sys.stderr, "daemonization part #2 failed: %d (%s)" % (error.errno, error.strerror)
        sys.exit(1)

    logger.info('daemonization ended: switching to %s' % [launcher_path, '--id', name])
    os.execv(launcher_path, (launcher_path, '--id', name))

def stop_launcher(name, config):
    logger = logging.getLogger()
    pid_file = os.path.join(config.pid_path, '%s.pid' % name)
    os.seteuid(0)
    os.setegid(0)
    f = open(pid_file)
    try:
        for line in f:
            try:
                logger.info('attempt to kill launcher "%s" (pid %d)' % (name, int(line)))
                os.kill(int(line), signal.SIGTERM)
                logger.info('launcher "%s" killed using SIGTERM' % name)
            except OSError:
                pass
            os.unlink(pid_file)
    finally:
        f.close()

if __name__ == "__main__":
    parser = optparse.OptionParser()
    parser.add_option("-c", "--config-file", help='path to the config file', default='/etc/mmc/pulse2/launchers/launchers.ini')
    parser.add_option("-o", "--id", help='id of this launcher')
    (options, args) = parser.parse_args()

    if not os.path.exists(options.config_file):
        print "Config file '%s' does not exist." % options.config_file
        sys.exit(1)

    if len(args)!=1:
        print "command is missing"
        sys.exit(2)

    # Load configuration file
    config = LauncherConfig()
    config.setup(options.config_file)
    config.check()

    # Set umask and effective UID and GID values
    os.umask(config.umask)
    os.setegid(config.daemon_group)
    os.seteuid(config.daemon_user)

    # Start logger
    logging.config.fileConfig(options.config_file)
    logger = logging.getLogger()

    if args[0] == "start":
        logger.info('starting Pulse2 Launchers')
        print('Starting Pulse2 Launchers:')
        # parse sections to keep launchers-specifics
        for section in config.launchers:
            #if re.compile("^launcher_[0-9]+$").match(section):
            print('\t%s' % section)
            start_launcher(section, config)
        logger.info('Launchers started')
    elif args[0] == "stop":
        logger.info('stopping Pulse2 Launchers')
        print('Stopping Pulse2 Launchers:')
        pid_path = config.pid_path
        if os.path.isdir(pid_path):
            for root, dirs, files in os.walk(pid_path):
                for myfile in files:
                    if re.compile('^launcher_[0-9]+\.pid$').match(myfile):
                        name = re.search('^(launcher_[0-9]+)\.pid$', myfile).group(1)
                        print('\t%s' % name)
                        stop_launcher(name, config)
        logger.info('Launchers stopped')



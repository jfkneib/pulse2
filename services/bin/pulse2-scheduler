#!/usr/bin/python
#
# -*- coding: utf-8; -*-
#
# (c) 2007-2008 Mandriva, http://www.mandriva.com/
#
# $Id$
#
# This file is part of Pulse 2, http://pulse2.mandriva.org
#
# Pulse 2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Pulse 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pulse 2; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

# Big modules
import os
import sys
import optparse
import xmlrpclib
import time

# Twisted
from twisted.internet import epollreactor
epollreactor.install()
import twisted.web.xmlrpc
import twisted.web.server
import twisted.internet.defer
import twisted.internet.base
from twisted.internet import ssl
try:
    from twisted.web import http
except ImportError:
    from twisted.protocols import http

# MMC
import mmc.support.mmctools

# XMLRPC funcs
import pulse2.scheduler.scheduling
import pulse2.scheduler.network
import pulse2.scheduler.launcher
import pulse2.scheduler.launchers_driving

# Filter SA warns to prevent trivial (hex/dec notation) error printing on STDOUT
import warnings
warnings.filterwarnings("ignore", category=FutureWarning)

# Other stuff
from pulse2.scheduler.config import SchedulerConfig
from pulse2.scheduler.xmlrpc import SchedulerSite
from pulse2.database.msc import MscDatabase
from pulse2.database.msc.config import MscDatabaseConfig
from mmc.plugins.base.computers import ComputerManager
from pulse2.scheduler.assign_algo import MGAssignAlgoManager
from pulse2.scheduler.health import getHealth

import pulse2.xmlrpc

# Logging
import logging
import logging.config

VERSION = "0.0.0"
REVISION = int("$Rev$".split(':')[1].strip(' $'))

def getVersion():  return VERSION
def getRevision(): return REVISION

def start_all_callbacks():
    startup_delay = 2
    logger = logging.getLogger()
    logger.info('scheduler "%s": will start to run callbacks in %d seconds' % (SchedulerConfig().name, startup_delay))
    time.sleep(startup_delay)
    scheduleAwakeScheduling()
    scheduleLogStats()
    logger.info('scheduler "%s": all callbacks started' % (SchedulerConfig().name))

def scheduleAwakeScheduling():
    start_commands_in = SchedulerConfig().awake_time - time.time() % SchedulerConfig().awake_time
    twisted.internet.reactor.callLater(start_commands_in, awakeScheduling)

def awakeScheduling():
    logger = logging.getLogger()
    logger.info('scheduler "%s": wake-up' % (SchedulerConfig().name))
    # start command, gather deffered
    try:
        pulse2.scheduler.scheduling.startAllCommands(SchedulerConfig().name)
    except Exception, e:
        logger.error("Error while running startAllCommands:")
        logger.error(e)
    try:
        pulse2.scheduler.scheduling.stopElapsedCommands(SchedulerConfig().name)
    except Exception, e:
        logger.error("Error while running stopElapsedCommands")
        logger.error(e)
    scheduleAwakeScheduling()

def scheduleLogStats():
    """ periodicaly log stats """
    delay = 60 - time.time() % 60
    twisted.internet.reactor.callLater(delay, logStats)

def logStats():
    logging.getLogger().info('scheduler %s: HEALTH: %s' % (SchedulerConfig().name, getHealth()))
    scheduleLogStats()

def startService():
    conffile = mmc.support.mmctools.getConfigFile("msc")
    confmsc = MscDatabaseConfig()
    confmsc.setup(conffile)
    if not MscDatabase().activate(confmsc): # does the db_check
        return 1

    logger = logging.getLogger()
    config = SchedulerConfig()
    if not config.username:
        logger.warn('scheduler %s: no username set !!' % (config.name))
    if not config.password:
        logger.warn('scheduler %s: no password set !!' % (config.name))
    # check versus MySQLdb version
    import MySQLdb
    (v1, v2, v3, v4, v5) = MySQLdb.version_info
    if v1 == 1:
        if v2 == 2:  # handling of v. 1.2.x+
            if v3 <= 1:
                if v4 != 'final': # versions up to 1.2.1c??? are buggy => injetc using ascii convertion
                    config.dbencoding = 'ascii'
                    logger.warn('scheduler "%s": python-mysqldb too old (spotted %s), using "ascii" as db encoding' % (config.name, MySQLdb.version_info))
    elif v2 <= 1: #handling of v. 1.1.x and 1.0.x
            config.dbencoding = 'ascii'
            logger.warn('scheduler "%s": python-mysqldb too old (spotted %s), using "ascii" as db encoding' % (config.name, MySQLdb.version_info))

    launchers = map(lambda(a): 'xml://%s:%s' % (config.launchers[a]['host'], config.launchers[a]['port']), config.launchers)
    logger.info('scheduler %s: available launchers: %s' % (config.name, ' '.join(launchers)))

    # put the machine to command group algorithm
    MGAssignAlgoManager().setAlgo(config.mg_assign_algo)

    # Starts XMLRPC server
    logger.info('scheduler %s: starting' % config.name)
    try:
        if config.enablessl:
            pulse2.xmlrpc.OpenSSLContext().setup(config.localcert, config.cacert, config.verifypeer)
            twisted.internet.reactor.listenSSL(
                config.port,
                SchedulerSite(Scheduler(config.name)),
                interface = config.host,
                contextFactory = pulse2.xmlrpc.OpenSSLContext().getContext()
                )
            logger.info('scheduler %s: activating SSL mode' % (config.name))
        else:
            twisted.internet.reactor.listenTCP(
                config.port,
                twisted.web.server.Site(Scheduler(config.name)),
                interface = config.host
                )
    except Exception, e:
        logger.error('scheduler %s: can\'t bind to %s:%d, reason is %s' % (config.name, config.host, config.port, e))
        return 1

    twisted.internet.reactor.callWhenRunning(start_all_callbacks)
    logger.info('scheduler %s: listening on %s:%d' % (config.name, config.host, config.port))
    twisted.internet.reactor.run()
    return 0

class Scheduler(twisted.web.xmlrpc.XMLRPC):
    """Our Scheduler
    """

    def __init__(self, name):
        twisted.web.xmlrpc.XMLRPC.__init__(self)
        self.logger = logging.getLogger()
        self.name = name

    def getRevision(self):
        return int("$Rev$".split(':')[1].strip(' $'))

    def getVersion(self):
        return VERSION

    def _ebRender(self, failure, func, args):
        self.logger.error(failure)
        if isinstance(failure.value, xmlrpclib.Fault):
            return failure.value
        return xmlrpclib.Fault(self.FAILURE, "Internal Error")

    def _cbRender(self, result, request, func, args):
        if isinstance(result, Scheduler):
            result = mmc.support.mmctools.xmlrpcCleanup(result.result)
        if not isinstance(result, xmlrpclib.Fault):
            result = (result,)
        self.logger.debug('xmlrpc: %s%s => %s' % (func, (args), (result)))
        try:
            s = xmlrpclib.dumps(result, methodresponse=1)
        except:
            f = xmlrpclib.Fault(self.FAILURE, "can't serialize output")
            s = xmlrpclib.dumps(f, methodresponse=1)
        request.setHeader("content-length", str(len(s)))
        request.write(s)
        request.finish()

    def render(self, request):
        """
        override method of xmlrpc python twisted framework
        """
        args, functionPath = xmlrpclib.loads(request.content.read())
        function = self._getFunction(functionPath)

        cleartext_token = '%s:%s' % (SchedulerConfig().username, SchedulerConfig().password)
        token = '%s:%s' % (request.getUser(), request.getPassword())
        if token != cleartext_token:
            self.logger.error("Invalid login / password for HTTP basic authentication")
            request.setResponseCode(http.UNAUTHORIZED)
            self._cbRender(
                twisted.web.xmlrpc.Fault(http.UNAUTHORIZED, "Unauthorized: invalid credentials to connect to this Pulse 2 Scheduler, basic HTTP authentication is required"),
                request,
                functionPath,
                args
                )
            return twisted.web.server.NOT_DONE_YET

        request.setHeader("content-type", "text/xml")
        twisted.internet.defer.maybeDeferred(function, *args).addErrback(
            self._ebRender, functionPath, args
        ).addCallback(
            self._cbRender, request, functionPath, args
        )
        return twisted.web.server.NOT_DONE_YET

    ### XMLRPC functions used from a MMC agent ###
    def xmlrpc_ping_client(self, uuid, fqdn, shortname, ips, macs):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launchers_driving.pingClient(uuid, fqdn, shortname, ips, macs))
    def xmlrpc_probe_client(self, uuid, fqdn, shortname, ips, macs):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launchers_driving.probeClient(uuid, fqdn, shortname, ips, macs))
    def xmlrpc_ping_and_probe_client(self, uuid, fqdn, shortname, ips, macs):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launchers_driving.pingAndProbeClient(uuid, fqdn, shortname, ips, macs))
    def xmlrpc_download_file(self, uuid, fqdn, shortname, ips, macs, path, bwlimit):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launchers_driving.downloadFile(uuid, fqdn, shortname, ips, macs, path, bwlimit))
    def xmlrpc_start_all_commands(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.scheduling.startAllCommands(self.name))
    def xmlrpc_start_these_commands(self, commands):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.scheduling.startTheseCommands(self.name, commands))
    def xmlrpc_start_command(self, id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.scheduling.startCommand(id))
    def xmlrpc_start_commands(self, cmdids):
        for cid in cmdids:
            mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.scheduling.startCommand(cid))
        return True
    def xmlrpc_stop_command(self, id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.scheduling.stopCommand(id))
    def xmlrpc_stop_commands(self, cmdids):
        pulse2.scheduler.scheduling.stopCommandsOnHosts(cmdids)
        return True
    def xmlrpc_tcp_sproxy(self, uuid, fqdn, shortname, ips, macs, requestor_ip, requested_port):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launchers_driving.establishProxy(uuid, fqdn, shortname, ips, macs, requestor_ip, requested_port))

    ### XMLRPC functions used from a launcher ###
    def xmlrpc_tell_i_am_alive(self, launcher):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launcher.tell_i_am_alive(launcher))
    def xmlrpc_completed_quick_action(self, launcher, (exitcode, stdout, stderr), id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launcher.completed_quick_action(launcher, (exitcode, stdout, stderr), id))
    def xmlrpc_completed_push(self, launcher, (exitcode, stdout, stderr), id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launcher.completed_push(launcher, (exitcode, stdout, stderr), id))
    def xmlrpc_completed_pull(self, launcher, (exitcode, stdout, stderr), id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launcher.completed_pull(launcher, (exitcode, stdout, stderr), id))
    def xmlrpc_completed_execution(self, launcher, (exitcode, stdout, stderr), id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launcher.completed_execution(launcher, (exitcode, stdout, stderr), id))
    def xmlrpc_completed_deletion(self, launcher, (exitcode, stdout, stderr), id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launcher.completed_deletion(launcher, (exitcode, stdout, stderr), id))
    def xmlrpc_completed_inventory(self, launcher, (exitcode, stdout, stderr), id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launcher.completed_inventory(launcher, (exitcode, stdout, stderr), id))
    def xmlrpc_completed_reboot(self, launcher, (exitcode, stdout, stderr), id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launcher.completed_reboot(launcher, (exitcode, stdout, stderr), id))
    def xmlrpc_completed_halt(self, launcher, (exitcode, stdout, stderr), id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launcher.completed_halt(launcher, (exitcode, stdout, stderr), id))

    def xmlrpc_get_pubkey(self, launcher, key_name):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launchers_driving.getPubKey(launcher, key_name))
    def xmlrpc_remote_exec(self, launcher, path):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.launchers_driving.getPubKey(launcher, key_name))
    def xmlrpc_get_health(self):
        return xmlrpcCleanup(getHealth())

def main():
    parser = optparse.OptionParser()
    parser.add_option("-c", "--config-file", help='path to the config file', default='/etc/mmc/pulse2/scheduler/scheduler.ini')
    (options, args) = parser.parse_args()

    if not os.path.exists(options.config_file):
        print "Config file '%s' does not exist." % options.config_file
        sys.exit(3)

    # start logger
    logging.config.fileConfig(options.config_file)
    logger = logging.getLogger()
    logger.info("Scheduler version('%s') build('%s')"%(str(getVersion()), str(getRevision())))

    # parse conf
    logger.info("Reading configuration file: %s" % options.config_file)
    try:
        SchedulerConfig().setup(options.config_file)
    except Exception, e:
        logger.error(e)
        logger.error("Please fix the configuration file")
        sys.exit(1)

    # start service
    sys.exit(startService())

if __name__ == '__main__':
    main()

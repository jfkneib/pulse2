#!/usr/bin/python
# -*- coding: utf-8; -*-
#
# (c) 2007 Mandriva, http://www.mandriva.com/
#
# $Id: pulse2-launcher 21 2008-01-14 14:47:49Z nrueff $
#
# This file is part of Pulse2.
#
# Pulse 2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Pulse 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pulse 2; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# Big modules
import os
import sys
import optparse
import xmlrpclib
import time

# Twisted
import twisted.web.xmlrpc
import twisted.web.server
import twisted.internet.defer
import twisted.internet.base
import twisted.internet.reactor

# MMC
import mmc.support.mmctools

# XMLRPC funcs
from pulse2.scheduler.config import SchedulerConfig
import pulse2.scheduler.management
import pulse2.scheduler.network

# Logging
import logging
import logging.config

VERSION = "0.0.0"

def reschedule_start_all_commands((deffered)):
    start_commands_in = int(time.time() % SchedulerConfig().start_commands_modulo) + 1

    logger = logging.getLogger()
    logger.info('scheduler "%s": startAllCommands will be called in %s seconds' % (SchedulerConfig().name, start_commands_in))

    twisted.internet.reactor.callLater(start_commands_in, run_start_all_commands)

def run_start_all_commands():
    logger = logging.getLogger()
    logger.info('scheduler "%s": startAllCommands started' % (SchedulerConfig().name))

    # start command, gather deffered
    deffereds = pulse2.scheduler.management.start_all_commands()

    # adds a end hook to reschedule prepare_start_all_commands
    dl = twisted.internet.defer.DeferredList(deffereds)
    dl.addCallback(reschedule_start_all_commands)


def startService(config_file):
    logger = logging.getLogger()
    config = SchedulerConfig()
    if not config.login:
        logger.warn('scheduler "%s": no username set !!' % (config.name))
    if not config.password:
        logger.warn('scheduler "%s": no password set !!' % (config.name))
    logger.info('scheduler "%s": listening on %s:%d' % (config.name, config.host, config.port))

    # Starting XMLRPC server
    logger.info('scheduler %s: starting' % config.name)
    try:
        twisted.internet.reactor.listenTCP(
            config.port,
            twisted.web.server.Site(Scheduler()),
            interface = config.host
        )
    except:
        logger.error('scheduler "%s": can\'t bind to %s:%d' % (config.name, config.host, config.port))
        return False

    # start periodic scheduler, called every start_commands_modulo seconds
    reschedule_start_all_commands(None)

    twisted.internet.reactor.run()
    return True

class Scheduler(twisted.web.xmlrpc.XMLRPC):
    """Our Scheduler
    """

    def __init__(self):
        twisted.web.xmlrpc.XMLRPC.__init__(self)
        self.logger = logging.getLogger()

    def getRevision(self):
        return int("$Rev: 298 $".split(':')[1].strip(' $'))

    def getVersion(self):
        return VERSION

    def _ebRender(self, failure):
        self.logger.error(failure)
        if isinstance(failure.value, xmlrpclib.Fault):
            return failure.value
        return xmlrpclib.Fault(self.FAILURE, "Internal Error")

    def _cbRender(self, result, request):
        args, func = xmlrpclib.loads(request.content.getvalue())
        if isinstance(result, Scheduler):
            result = mmc.support.mmctools.xmlrpcCleanup(result.result)
        if not isinstance(result, xmlrpclib.Fault):
            result = (result,)
        self.logger.debug('xmlrpc: %s%s => %s' % (func, (args), (result)))
        try:
            s = xmlrpclib.dumps(result, methodresponse=1)
        except:
            f = xmlrpclib.Fault(self.FAILURE, "can't serialize output")
            s = xmlrpclib.dumps(f, methodresponse=1)
        request.setHeader("content-length", str(len(s)))
        request.write(s)
        request.finish()

    def xmlrpc_ping_client(self, client):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.network.ping_client(client))

    def xmlrpc_probe_client(self, client):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.scheduler.network.probe_client(client))

    def xmlrpc_start_all_commands(self):
        return mmc.support.mmctools.xmlrpcCleanup(len(pulse2.scheduler.management.start_all_commands()))

def main():
    parser = optparse.OptionParser()
    parser.add_option("-c", "--config-file", help='path to the config file', default='/etc/mmc/pulse2/scheduler.ini')
    (options, args) = parser.parse_args()

    if not os.path.exists(options.config_file):
        print "Config file '%s' does not exist." % options.config_file
        sys.exit(3)

    # start logger
    logging.config.fileConfig(options.config_file)
    logger = logging.getLogger()

    # parse conf
    SchedulerConfig().setup(options.config_file)

    # start service
    sys.exit(startService(options.config_file))

if __name__ == '__main__':
    main()

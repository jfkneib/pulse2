#!/usr/bin/python
# -*- coding: utf-8; -*-
#
# (c) 2007-2008 Mandriva, http://www.mandriva.com/
#
# $Id$
#
# This file is part of Pulse 2, http://pulse2.mandriva.org
#
# Pulse 2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Pulse 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pulse 2; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

# Big modules
import os
import sys
import optparse
import xmlrpclib
import time

# Twisted
import twisted.web.xmlrpc
import twisted.web.server
import twisted.internet.defer
import twisted.internet.reactor

# Misc
import ConfigParser

# MMC
import mmc.support.mmctools

# Other stuff
from pulse2.launcher.config import LauncherConfig
import pulse2.launcher.utils

# XMLRPC funcs
import pulse2.launcher.remote_exec

# Logging
import logging
import logging.config

VERSION = "0.0.0"

def scheduleTellIAmAlive():
    """ periodicaly talk to our referent scheduler """
    tell_in = int(time.time() % LauncherConfig().i_am_alive_modulo) + 1
    twisted.internet.reactor.callLater(tell_in, tellIAmAlive)

def tellIAmAlive():
    def _cb(result):
        pass
    def _eb(reason):
        logger = logging.getLogger()
        logger.warn('launcher "%s": failed to contact our scheduler at %s, reason: %s' % (LauncherConfig().name, scheduler, reason))
        pass

    scheduler = pulse2.launcher.utils.getScheduler()
    logger = logging.getLogger()
    logger.info('launcher "%s": contacting our scheduler at %s' % (LauncherConfig().name, scheduler))

    mydeffered = twisted.web.xmlrpc.Proxy(scheduler).callRemote('tell_i_am_alive', LauncherConfig().name)
    mydeffered.\
        addCallback(_cb).\
        addErrback(_eb)
    scheduleTellIAmAlive()

def startService():
    logger = logging.getLogger()
    config = LauncherConfig()

    name = config.name
    port = int(config.launchers[config.name]['port'])
    bind = config.launchers[config.name]['bind']

    # Starting XMLRPC server
    launcher = Launcher(name)
    try:
        twisted.internet.reactor.listenTCP(port, twisted.web.server.Site(launcher), interface = bind)
    except:
        logger.error('launcher "%s": can\'t bind to %s:%d' % (name, bind, port))
        return 1

    # start periodic scheduler probing, called every i_am_alive_modulo seconds
    scheduleTellIAmAlive()
    logger.info('launcher "%s": listening on %s:%d' % (name, bind, port))

    twisted.internet.reactor.run()
    return 0

class Launcher(twisted.web.xmlrpc.XMLRPC):
    """Our launcher
    """

    def __init__(self, name):
        twisted.web.xmlrpc.XMLRPC.__init__(self)
        self.name = name
        self.logger = logging.getLogger()
        self.config = LauncherConfig().launchers[name]

    def getRevision(self):
        return int("$Rev: 298 $".split(':')[1].strip(' $'))

    def getVersion(self):
        return VERSION

    def _ebRender(self, failure):
        self.logger.error(failure)
        if isinstance(failure.value, xmlrpclib.Fault):
            return failure.value
        return xmlrpclib.Fault(self.FAILURE, "Internal Error on launcher %s" % self.name)

    def _cbRender(self, result, request):
        args, func = xmlrpclib.loads(request.content.getvalue())
        if isinstance(result, Launcher):
            result = mmc.support.mmctools.xmlrpcCleanup(result.result)
        if not isinstance(result, xmlrpclib.Fault):
            result = (result,)
        self.logger.debug('%s: xmlrpc: %s%s => %s' % (self.name, func, (args), (result)))
        try:
            s = xmlrpclib.dumps(result, methodresponse=1)
        except:
            f = xmlrpclib.Fault(self.FAILURE, "can't serialize output")
            s = xmlrpclib.dumps(f, methodresponse=1)
        request.setHeader("content-length", str(len(s)))
        request.write(s)
        request.finish()

    def xmlrpc_sync_remote_push(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_push(command_id, client, files_list))
    def xmlrpc_async_remote_push(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_push(command_id, client, files_list))

    def xmlrpc_sync_remote_pull(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_pull(command_id, client, files_list))
    def xmlrpc_async_remote_pull(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_pull(command_id, client, files_list))

    def xmlrpc_sync_remote_delete(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_delete(command_id, client, files_list))
    def xmlrpc_async_remote_delete(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_delete(command_id, client, files_list))

    def xmlrpc_sync_remote_exec(self, command_id, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_exec(command_id, client, command))
    def xmlrpc_async_remote_exec(self, command_id, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_exec(command_id, client, command))

    def xmlrpc_sync_remote_quickaction(self, command_id, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_quickaction(command_id, client, command))
    def xmlrpc_async_remote_quickaction(self, command_id, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_quickaction(command_id, client, command))

    def xmlrpc_sync_remote_wol(self, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_wol(command_id, client))

    def xmlrpc_sync_remote_inventory(self, command_id, client):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_inventory(command_id, client))

    def xmlrpc_get_background_process_count(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.get_background_process_count())

    def xmlrpc_get_background_process_list(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.get_background_process_list())

    def xmlrpc_get_background_running_process_count(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.get_background_running_process_count())

    def xmlrpc_get_background_running_process_list(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.get_background_running_process_list())

    def xmlrpc_is_background_process_done(self, name):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.is_background_process_done(name))

    def xmlrpc_purge_background_process(self, name):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.purge_background_process(name))

def main():
    parser = optparse.OptionParser()
    parser.add_option("-c", "--config-file", help='path to the config file', default='/etc/mmc/pulse2/launchers.ini')
    parser.add_option("-i", "--id", help='id of this launcher')
    (options, args) = parser.parse_args()

    if not os.path.exists(options.config_file):
        print "Config file '%s' does not exist." % options.config_file
        sys.exit(3)

    # start logger
    logging.config.fileConfig(options.config_file)
    logger = logging.getLogger()
    logger.info('launcher %s: starting' % options.id)

    # parse conf
    LauncherConfig().setup(options.config_file, options.id)

    # start service
    sys.exit(startService())

if __name__ == '__main__':
    main()

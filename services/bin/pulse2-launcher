#!/usr/bin/python
# -*- coding: utf-8; -*-
#
# (c) 2007 Mandriva, http://www.mandriva.com/
#
# $Id$
#
# This file is part of Pulse2.
#
# Pulse 2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Pulse 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pulse 2; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# Big modules
import os
import sys
import optparse
import xmlrpclib

# Twisted
import twisted.web.xmlrpc
import twisted.web.server
import twisted.internet.defer
import twisted.internet.reactor

# Misc
import ConfigParser

# MMC
import pulse2.launcher.remote_exec
import mmc.support.mmctools

# Logging
import logging
import logging.config

VERSION = "0.0.0"

def startService(name, config_file):
    # Load configuration file
    cp = ConfigParser.ConfigParser()
    cp.read(config_file)

    logger = logging.getLogger()

    if cp.has_option(name, "port"):
        port = cp.getint(name, "port")
    else:
        port = 8001 # FIXME: explain this to user

    if cp.has_option(name, "host"):
        host = cp.get(name, "host")
    elif cp.has_option("launchers", "host"):
        host = cp.get("launchers", "host")
    else:
        host = "127.0.0.1" # FIXME: explain this to user

    logger.info('launcher "%s": listening on %s:%d' % (name, host, port))

    if cp.has_option(name, "login"):
        login = cp.get(name, "login")
    elif cp.has_option("launchers", "login"):
        login = cp.get("launchers", "login")
    else:
        login = ""
        logger.warn('launcher "%s": no username set !!' % (name))

    if cp.has_option(name, "password"):
        password = cp.get(name, "password")
    elif cp.has_option("launchers", "password"):
        password = cp.get("launchers", "password")
    else:
        password = ""
        logger.warn('launcher "%s": no password set !!' % (name))

    # Starting XMLRPC server
    launcher = Launcher(name, cp, login, password)
    try:
        twisted.internet.reactor.listenTCP(port, twisted.web.server.Site(launcher), interface = host)
    except:
        logger.error('launcher "%s": can\'t bind to %s:%d' % (name, host, port))
        return False
    twisted.internet.reactor.run()
    return True

class Launcher(twisted.web.xmlrpc.XMLRPC):
    """Our launcher
    """

    def __init__(self, name, config, login="", password=""):
        twisted.web.xmlrpc.XMLRPC.__init__(self)
        self.id = name
        self.logger = logging.getLogger()
        self.login = login
        self.password = password
        self.cp = config
        self.wrapper = self.cp.get('launchers', 'wrapper_path') # FIXME: check wrapper availability
        self.source_path = self.cp.get('launchers', 'source_path') # FIXME: check source path existence
        self.target_path = self.cp.get('launchers', 'target_path') # FIXME: check target path existence
        self.inventory_command = self.cp.get('launchers', 'inventory_command')

    def getRevision(self):
        return int("$Rev: 298 $".split(':')[1].strip(' $'))

    def getVersion(self):
        return VERSION

    def _ebRender(self, failure):
        self.logger.error(failure)
        if isinstance(failure.value, xmlrpclib.Fault):
            return failure.value
        return xmlrpclib.Fault(self.FAILURE, "Internal Error")

    def _cbRender(self, result, request):
        args, func = xmlrpclib.loads(request.content.getvalue())
        if isinstance(result, Launcher):
            result = mmc.support.mmctools.xmlrpcCleanup(result.result)
        if not isinstance(result, xmlrpclib.Fault):
            result = (result,)
        self.logger.debug('xmlrpc: %s%s => %s' % (func, (args), (result)))
        try:
            s = xmlrpclib.dumps(result, methodresponse=1)
        except:
            f = xmlrpclib.Fault(self.FAILURE, "can't serialize output")
            s = xmlrpclib.dumps(f, methodresponse=1)
        request.setHeader("content-length", str(len(s)))
        request.write(s)
        request.finish()

    def xmlrpc_sync_remote_push(self, command_id, client, files_list):
        """
        TODO: check that source_path is authorized (using conf file)
        TODO: check that target_path is authorized (using conf file)
        """
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_push(command_id, client, self.source_path, self.target_path, files_list, self.wrapper))

    def xmlrpc_sync_remote_pull(self, command_id, client, files_list):
        """
        TODO: check that source_path is authorized (using conf file)
        TODO: check that target_path is authorized (using conf file)
        """
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_pull(command_id, client, self.target_path, files_list, self.wrapper))

    def xmlrpc_sync_remote_delete(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_delete(command_id, client, self.target_path, files_list, self.wrapper))

    def xmlrpc_sync_remote_exec(self, command_id, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_exec(command_id, client, self.target_path, command, self.wrapper))

    def xmlrpc_sync_remote_inventory(self, command_id, client):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_inventory(command_id, client, self.inventory_command, self.wrapper))

    def xmlrpc_async_remote_exec(self, name, command, client=None):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_exec(name, command, client, self.wrapper))

    def xmlrpc_get_background_process_count(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.get_background_process_count())

    def xmlrpc_get_background_process_list(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.get_background_process_list())

    def xmlrpc_get_background_running_process_count(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.get_background_running_process_count())

    def xmlrpc_get_background_running_process_list(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.get_background_running_process_list())

    def xmlrpc_is_background_process_done(self, name):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.is_background_process_done(name))

    def xmlrpc_purge_background_process(self, name):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.purge_background_process(name))

def main():
    parser = optparse.OptionParser()
    parser.add_option("-c", "--config-file", help='path to the config file', default='/etc/mmc/pulse2/launchers.ini')
    parser.add_option("-i", "--id", help='id of this launcher')
    (options, args) = parser.parse_args()

    if not os.path.exists(options.config_file):
        print "Config file '%s' does not exist." % options.config_file
        sys.exit(3)

    # start logger
    logging.config.fileConfig(options.config_file)
    logger = logging.getLogger()
    logger.info('launcher %s: starting' % options.id)

    # start service
    sys.exit(startService(options.id, options.config_file))

if __name__ == '__main__':
    main()

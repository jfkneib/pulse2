#!/usr/bin/python
# -*- coding: utf-8; -*-
#
# (c) 2007-2008 Mandriva, http://www.mandriva.com/
#
# $Id$
#
# This file is part of Pulse 2, http://pulse2.mandriva.org
#
# Pulse 2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Pulse 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pulse 2; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

# Big modules
import os
import sys
import optparse
import xmlrpclib
import time

# Twisted
import twisted.web.xmlrpc
import twisted.web.server
import twisted.internet.defer
import twisted.internet.reactor
try:
    from twisted.web import http
except ImportError:
    from twisted.protocols import http

# Misc
import ConfigParser

# MMC
import mmc.support.mmctools

# Other stuff
from pulse2.launcher.config import LauncherConfig
import pulse2.launcher.utils

# XMLRPC funcs
import pulse2.launcher.remote_exec
import pulse2.launcher.process_control
import pulse2.launcher.network

# Logging
import logging
import logging.config

VERSION = "0.0.0"

def scheduleTellIAmAlive():
    """ periodicaly talk to our referent scheduler """
    tell_in = LauncherConfig().awake_time - time.time() % LauncherConfig().awake_time
    twisted.internet.reactor.callLater(tell_in, tellIAmAlive)

def tellIAmAlive():
    """ Function wich became more and more large """
    def _cb(result): # scheduler do answer us, check if there is some zombies to expunge around
        if pulse2.launcher.process_control.ProcessList().getZombiesCount() > 0:
            logging.getLogger().info('launcher %s: sending available results to our scheduler at %s' % (LauncherConfig().name, scheduler))
            for id in pulse2.launcher.process_control.ProcessList().getZombieIds():
                pulse2.launcher.process_control.ProcessList().getProcess(id).installEndBack()

    def _eb(reason): # can't contact scheduler, log and continue
        logging.getLogger().error('launcher %s: failed to contact our scheduler at %s: %s' % (LauncherConfig().name, scheduler, reason.value))

    # retrieve referent scheduler
    scheduler = pulse2.launcher.utils.getScheduler()

    # salute our referent scheduler
    mydeffered = twisted.web.xmlrpc.Proxy(scheduler).callRemote('tell_i_am_alive', LauncherConfig().name)
    mydeffered.\
        addCallback(_cb).\
        addErrback(_eb)
    scheduleTellIAmAlive()

def startService():
    logger = logging.getLogger()
    config = LauncherConfig()

    name = config.name
    port = int(config.launchers[config.name]['port'])
    bind = config.launchers[config.name]['bind']
    enablessl = config.launchers[config.name]['enablessl']
    slots = config.launchers[config.name]['slots']
    wrapper_max_exec_time = config.wrapper_max_exec_time

    # Starting XMLRPC server
    launcher = Launcher(name)
    try:
        if enablessl:
            if not os.path.isfile(config.launchers[config.name]["privkey"]):
                logger.error('launcher %s: can\'t read SSL key "%s"' % (name, config.launchers[config.name]["privkey"]))
                return 1
            if not os.path.isfile(config.launchers[config.name]["certfile"]):
                logger.error('launcher %s: can\'t read SSL certificate "%s"' % (name, config.launchers[config.name]["certfile"]))
                return 1
            sslContext = twisted.internet.ssl.DefaultOpenSSLContextFactory(config.launchers[config.name]["privkey"], config.launchers[config.name]["certfile"])
            twisted.internet.reactor.listenSSL(
                port,
                twisted.web.server.Site(launcher),
                interface = bind,
                contextFactory = sslContext
                )
            logger.info('launcher %s: activating SSL mode' % (name))
        else:
            twisted.internet.reactor.listenTCP(
                port,
                twisted.web.server.Site(launcher),
                interface = bind
                )
    except Exception, e:
        logger.error('launcher %s: can\'t bind to %s:%d' % (name, bind, port))
        logger.error(e)
        return 1

    pulse2.launcher.process_control.ProcessList().setup(slots, wrapper_max_exec_time)

    # Start periodic scheduler probing, called every awake_time seconds
    tellIAmAlive()
    logger.info('launcher %s: %d slots, listening on %s:%d' % (name, slots, bind, port))

    twisted.internet.reactor.run()
    return 0

class Launcher(twisted.web.xmlrpc.XMLRPC):
    """Our launcher
    """

    def __init__(self, name):
        twisted.web.xmlrpc.XMLRPC.__init__(self)
        self.name = name
        self.logger = logging.getLogger()
        self.config = LauncherConfig().launchers[name]

    def getRevision(self):
        return int("$Rev: 298 $".split(':')[1].strip(' $'))

    def getVersion(self):
        return VERSION

    def _ebRender(self, failure):
        self.logger.error(failure)
        if isinstance(failure.value, xmlrpclib.Fault):
            return failure.value
        return xmlrpclib.Fault(self.FAILURE, "Internal Error on launcher %s" % self.name)

    def _cbRender(self, result, request):
        args, func = xmlrpclib.loads(request.content.getvalue())
        if isinstance(result, Launcher):
            result = mmc.support.mmctools.xmlrpcCleanup(result.result)
        if not isinstance(result, xmlrpclib.Fault):
            result = (result,)
        self.logger.debug('%s: xmlrpc: %s%s => %s' % (self.name, func, (args), (result)))
        try:
            s = xmlrpclib.dumps(result, methodresponse=1)
        except:
            f = xmlrpclib.Fault(self.FAILURE, "can't serialize output")
            s = xmlrpclib.dumps(f, methodresponse=1)
        request.setHeader("content-length", str(len(s)))
        request.write(s)
        request.finish()

    def render(self, request):
        """
        override method of xmlrpc python twisted framework
        """
        headers = request.getAllHeaders()
        args, functionPath = xmlrpclib.loads(request.content.read())
        function = self._getFunction(functionPath)

        cleartext_token = '%s:%s' % (self.config['username'], self.config['password'])
        token = '%s:%s' % (request.getUser(), request.getPassword())
        if token != cleartext_token:
            self.logger.error("Invalid login / password for HTTP basic authentication")
            request.setResponseCode(http.UNAUTHORIZED)
            self._cbRender(
                twisted.web.xmlrpc.Fault(http.UNAUTHORIZED, "Unauthorized: invalid credentials to connect to this Pulse 2 Launcher, basic HTTP authentication is required"),
                request
                )
            return twisted.web.server.NOT_DONE_YET

        request.setHeader("content-type", "text/xml")
        twisted.internet.defer.maybeDeferred(function, *args).addErrback(
            self._ebRender
        ).addCallback(
            self._cbRender, request
        )
        return twisted.web.server.NOT_DONE_YET

    # Synchrone commands summoning
    def xmlrpc_sync_remote_push(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_push(command_id, client, files_list))
    def xmlrpc_sync_remote_pull(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_pull(command_id, client, files_list))
    def xmlrpc_sync_remote_delete(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_delete(command_id, client, files_list))
    def xmlrpc_sync_remote_exec(self, command_id, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_exec(command_id, client, command))
    def xmlrpc_sync_remote_quickaction(self, command_id, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_quickaction(command_id, client, command))
    def xmlrpc_sync_remote_inventory(self, command_id, client):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_inventory(command_id, client))
    def xmlrpc_sync_remote_wol(self, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.sync_remote_wol(command_id, client))

    # Asynchrone commands summoning
    def xmlrpc_async_remote_push(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_push(command_id, client, files_list))
    def xmlrpc_async_remote_pull(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_pull(command_id, client, files_list))
    def xmlrpc_async_remote_delete(self, command_id, client, files_list):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_delete(command_id, client, files_list))
    def xmlrpc_async_remote_exec(self, command_id, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_exec(command_id, client, command))
    def xmlrpc_async_remote_quickaction(self, command_id, client, command):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_quickaction(command_id, client, command))
    def xmlrpc_async_remote_inventory(self, command_id, client):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.remote_exec.async_remote_inventory(command_id, client))

    # Background process lists
    def xmlrpc_get_process_count(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getProcessCount())
    def xmlrpc_get_running_count(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getRunning_count())
    def xmlrpc_get_zombie_count(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getZombiesCount())
    def xmlrpc_get_process_ids(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getProcessIds())
    def xmlrpc_get_running_ids(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getRunningIds())
    def xmlrpc_get_zombie_ids(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getZombieIds())

    # Background process statistics
    def xmlrpc_get_process_stdout(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getProcessStdout(command_id))
    def xmlrpc_get_process_stderr(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getProcessStderr(command_id))
    def xmlrpc_get_process_exitcode(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getProcessExitcode(command_id))
    def xmlrpc_get_process_times(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getProcessTimes(command_id))
    def xmlrpc_get_process_state(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getProcessState(command_id))
    def xmlrpc_get_process_statistics(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.getProcessStatistics(command_id))

    # Background process handling
    def xmlrpc_stop_process(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.stopProcess(command_id))
    def xmlrpc_cont_process(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.contProcess(command_id))
    def xmlrpc_int_process(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.intProcess(command_id))
    def xmlrpc_kill_process(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.killProcess(command_id))
    def xmlrpc_hup_process(self, command_id):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.hupProcess(command_id))

    # Massive background process lists
    def xmlrpc_stop_all_process(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.stopAllProcess())
    def xmlrpc_cont_all_process(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.contAllProcess())
    def xmlrpc_int_all_process(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.intAllProcess())
    def xmlrpc_kill_all_process(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.killAllProcess())
    def xmlrpc_hup_all_process(self):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.process_control.hupAllProcess())

    # Network stuff handling
    def xmlrpc_wol(self, mac_addrs):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.network.wolClient(mac_addrs))
    def xmlrpc_icmp(self, client):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.network.icmpClient(client))

    def xmlrpc_get_pubkey(self, key_name):
        return mmc.support.mmctools.xmlrpcCleanup(pulse2.launcher.utils.getPubKey(key_name))

    def xmlrpc_get_health(self):
        return pulse2.launcher.utils.getHealth(self.config)

def main():
    parser = optparse.OptionParser()
    parser.add_option("-c", "--config-file", help='path to the config file', default='/etc/mmc/pulse2/launchers/launchers.ini')
    parser.add_option("-i", "--id", help='id of this launcher')
    (options, args) = parser.parse_args()

    if not os.path.exists(options.config_file):
        print "Config file '%s' does not exist." % options.config_file
        sys.exit(3)

    if not options.id:
        print "The launcher id should be specified on the command line with --id option"
        sys.exit(3)

    # start logger
    logging.config.fileConfig(options.config_file)
    logger = logging.getLogger()
    logger.info('launcher %s: starting' % options.id)

    # parse conf
    logger.info("launcher %s: Reading configuration file: %s" % (options.id, options.config_file))
    try:
        LauncherConfig().setup(options.config_file, options.id)
    except Exception, e:
        logger.error(e)
        logger.error("Please fix the configuration file")
        sys.exit(1)

    # start service
    sys.exit(startService())

if __name__ == '__main__':
    main()

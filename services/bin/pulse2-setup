#!/usr/bin/env python
# -*- coding: utf-8; -*-
#
# (c) 2011 Mandriva, http://www.mandriva.com/
#
# Author(s):
#   Jean Parpaillon <jparpaillon@mandriva.com>
#
# $Id$
#
# This file is part of Pulse 2, http://pulse2.mandriva.org
#
# Pulse 2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Pulse 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pulse 2.  If not, see <http://www.gnu.org/licenses/>.
import os, sys, stat
import readline, getpass
import string
from random import choice
from subprocess import call
from optparse import OptionParser
from ConfigParser import ConfigParser
import sqlalchemy as sa
import logging
import ldap

log = logging.getLogger('pulse2-setup')

def read_opt(prompt, default=None):
    if default is not None:
        prompt += ' (default: %s)' % default
    prompt = 'INPUT    - ' + prompt + ': '
    s = raw_input(prompt)
    if len(s)==0 and default is not None:
        s = default
    return s

def read_bool(prompt, default):
    if default is True:
        prompt += ' (Y/n)'
    else:
        prompt += ' (y/N)'
    prompt = 'INPUT    - ' + prompt + ': '
    correct = False
    ret = default
    while not correct:
        s = raw_input(prompt)
        if len(s)==0:
            break

        if s in ['y', 'Y']:
            correct = True
            ret = True
        elif s in ['n', 'N']:
            correct = True
            ret = False
        else:
            log.info('Incorrect value. Retry.')
    return ret

def gen_passwd(size=10):
    return ''.join([choice(string.letters + string.digits) for _ in range(size)])

def read_passwd(prompt, check=False):
    match = False
    while not match:
        pwd = getpass.getpass('INPUT    - ' + prompt + ': ')
        if check:
            pwd2 = getpass.getpass('INPUT    - ' + prompt + ' (confirm): ')
            match = pwd==pwd2
            if not match:
                log.info('Passwords do not match. Retry.')
        else:
            match = True
    return pwd

initscripts = [ 'mmc-agent', 'pulse2-imaging-server', 'pulse2-inventory-server',
                'pulse2-launchers', 'pulse2-package-server', 'pulse2-scheduler' ]

class DistroHandler(object):
    def enable_srv(self, name):
        ret = call("/bin/ln -fs ../init.d/%(name)s /etc/rc2.d/S20%(name)s" % {'name': name}, 
                   shell=True)
        return ret==0

    def disable_srv(self, name):
        ret = call("/bin/rm -f /etc/rc2.d/S20%(name)s" % {'name': name},
                   shell=True)
        return ret==0

    def start_srv(self, name):
        ret = call("/etc/rc2.d/S20%(name)s start" % {'name': name}, shell=True)
        return ret==0

    def stop_srv(self, name):
        ret = call("/etc/rc2.d/S20%(name)s stop" % {'name': name}, shell=True)
        return ret==0

class DebianHandler(DistroHandler):
    def enable_srv(self, name):
        ret = call("/usr/sbin/update-rc.d %(name)s defaults" % {'name': name}, 
                   shell=True)
        return ret== 0

    def disable_srv(self, name):
        ret = call("/usr/sbin/update-rc.d -f %(name)s remove" % {'name': name},
                   shell=True)
        return ret==0

    def start_srv(self, name):
        ret = call("/usr/sbin/invoke-rc.d %(name)s start" % {'name': name}, 
                   shell=True)
        return ret==0

    def stop_srv(self, name):
        ret = call("/usr/sbin/invoke-rc.d %(name)s stop" % {'name': name}, 
                   shell=True)
        return ret==0

def get_distro_handler():
    if os.path.exists('/usr/sbin/update-rc.d'):
        return DebianHandler()
    else:
        return DistroHandler()

class Service(object):
    name = None
    clsnames = [ 'SrvMmcAgent', 'SrvImagingServer', 'SrvInventoryserver',
                 'SrvLauncher', 'SrvPkgServer', 'SrvScheduler' ]

    def __init__(self, handler, config):
        self.config = config
        self.handler = handler

    def is_enable(self):
        return True

    def update_rc(self):
        if self.is_enable():
            self.enable_srv()
        else:
            self.disable_srv()

    def enable_srv(self):
        log.info('Enabling service: %s' % self.name)
        if not self.handler.enable_srv(self.name):
            log.error('Can not enable service: %s' % self.name)
            sys.exit(1)

    def disable_srv(self):
        log.info('Disabling service: %s' % self.name)
        if not self.handler.disable_srv(self.name):
            log.error('Can not disable service: %s' % self.name)
            sys.exit(1)

    def restart(self, fatal=False):
        log.info('Stopping service: %s' % self.name)
        self.handler.stop_srv(self.name)
        if self.is_enable():
            log.info('Starting service: %s' % self.name)
            if not self.handler.start_srv(self.name):
                log.warn('Can not start service: %s' % self.name)
                if fatal:
                    sys.exit(1)

class SrvMmcAgent(Service):
    name = 'mmc-agent'

    def restart(self, *args, **kwargs):
        super(SrvMmcAgent, self).restart(fatal=True)

class SrvImagingServer(Service):
    name = 'pulse2-imaging-server'

    def is_enable(self):
        return self.config['imaging.service.enable']

class SrvInventoryserver(Service):
    name = 'pulse2-inventory-server'

    def is_enable(self):
        return self.config['inventory.service.enable']

class SrvLauncher(Service):
    name = 'pulse2-launchers'

class SrvPkgServer(Service):
    name = 'pulse2-package-server'

    def is_enable(self):
        return self.config['package.service.enable']

class SrvScheduler(Service):
    name = 'pulse2-scheduler'

class Pulse2ConfigParser(ConfigParser):
    clsnames = [ 'PluginsPkgConfig', 'PluginsImagingConfig', 'PluginsGlpiConfig',
                 'PluginsBaseConfig', 'PluginsDyngroupConfig', 'PluginsInventoryConfig',
                 'PluginsPulse2Config', 'PluginsMscConfig', 'InventoryServerConfig', 
                 'LaunchersConfig', 'PackageServerConfig', 'SchedulerConfig',
                 'ImagingServerConfig' ]
    path = None
    defaults = {}
    mode = stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP

    def __init__(self, confdir):
        ConfigParser.__init__(self)
        self.confdir = confdir
        self._populate(self.__class__.defaults)
        self._load()

    def _load(self):
        """ Load config file, if any
        """
        fpath = os.path.join(self.confdir, self.path)
        if self.read(fpath):
            log.debug("Load config file %s" % fpath)
        else:
            log.debug("No such file %s. Will create it." % fpath)

    def _populate(self, d):
        for (name, section) in d.iteritems():
            if not self.has_section(name):
                self.add_section(name)
            for (opt, value) in section.iteritems():
                self.set(name, opt, value)

    def write_path(self, path):
        dirname = os.path.dirname(path)
        if not os.path.isdir(dirname):
            os.makedirs(dirname)
        try:
            f = open(path, 'w')
            self.write(f)
            os.chmod(path, self.mode)
            log.info("Wrote configuration file: %s" % path)
        except IOError, e:
            log.error("Can not write file: %s" % path)
            log.debug(str(e))
            sys.exit(1)
        finally:
            f.close()

    def commit(self):
        self.write_path(os.path.join(self.confdir, self.path))

class LoggingConfig(Pulse2ConfigParser):
    log_dir = '/var/log/mmc'
    log_path = None

    def __init__(self, *args, **kwargs):
        Pulse2ConfigParser.__init__(self, *args, **kwargs)
        
        # Add logging module configuration
        d = {'loggers': {'keys': 'root'},
             'handlers': {'keys': 'hand01'},
             'formatters': {'keys': 'form01'},
             'logger_root': {'level': 'NOTSET',
                             'handlers': 'hand01'},
             'handler_hand01': {'class': 'FileHandler',
                                'level': 'INFO',
                                'formatter': 'form01',
                                'args': (os.path.join(self.log_dir, self.log_path), )},
             'formatter_form01': {'format': '%(asctime)s %(levelname)s %(message)s'}}
        self._populate(d)

class PluginsPkgConfig(Pulse2ConfigParser):
    path = 'plugins/pkgs.ini'
    defaults = {'main': {'disable': 0},
                'user_package_api': {}}

class PluginsImagingConfig(Pulse2ConfigParser):
    path = 'plugins/imaging.ini'
    defaults = {'main': {'disable': 0},
                'database': {'dbdriver': 'mysql',
                             'dbhost': 'localhost',
                             'dbport': 3306,
                             'dbname': 'imaging',
                             'dbuser': 'mmc',
                             'dbpasswd': 'mmc'},
                'web': {}}

class PluginsGlpiConfig(Pulse2ConfigParser):
    path = 'plugins/glpi.ini'
    defaults = {'main': {'disable': 1},
                'querymanager': {}}

class PluginsBaseConfig(Pulse2ConfigParser):
    path = 'plugins/base.ini'
    defaults = {'backup-tools': {'path': '/usr/lib/mmc/backup-tools',
                                 'destpath': '/home/archives'},
                'ldap': {'ldapurl': 'ldap://localhost:389',
                         'basedn': 'dc=mandriva,dc=com',
                         'rootname': 'cn=admin,%(basedn)s',
                         'password': 'secret',
                         'baseusersdn': 'ou=Users,%(basedn)s',
                         'basegroupsdn': 'ou=Groups,%(basedn)s',
                         'userhomeaction': 1,
                         'logfile': '/var/log/ldap.log'},
                'computers': {'method': 'inventory'}}

class PluginsDyngroupConfig(Pulse2ConfigParser):
    path = 'plugins/dyngroup.ini'
    defaults = {'main': {'disable': 0, 
                         'dynamic_enable': 1},
                'database': {'dbdriver': 'mysql',
                             'dbhost': 'localhost',
                             'dbport': 3306,
                             'dbname': 'dyngroup',
                             'dbuser': 'mmc',
                             'dbpasswd': 'mmc'},
                'querymanager': {'activate': 1}}

class PluginsInventoryConfig(Pulse2ConfigParser):
    path = 'plugins/inventory.ini'
    defaults = {'main': {'disable': 0},
                'inventory': {'dbdriver': 'mysql',
                              'dbhost': 'localhost',
                              'dbname': 'inventory',
                              'dbuser': 'mmc',
                              'dbpasswd': 'mmc'},
                'expert_mode': {},
                'graph': {},
                'computers': {}}

class PluginsPulse2Config(Pulse2ConfigParser):
    path = 'plugins/pulse2.ini'
    defaults = {'main': {'disable': 0},
                'database': {'dbdriver': 'mysql',
                             'dbhost': 'localhost',
                             'dbname': 'pulse2',
                             'dbuser': 'mmc',
                             'dbpasswd': 'mmc'}}

class PluginsMscConfig(Pulse2ConfigParser):
    path = 'plugins/msc.ini'
    defaults = {'main': {'disable': 0},
                'msc': {'dbdriver': 'mysql',
                        'dbhost': 'localhost',
                        'dbname': 'msc',
                        'dbuser': 'mmc',
                        'dbpasswd': 'mmc',
                        'qactionpath': '/var/lib/pulse2/qactions',
                        'repopath': '/var/lib/pulse2/packages'}}

class InventoryServerConfig(LoggingConfig):
    path = 'pulse2/inventory-server/inventory-server.ini'
    log_path = 'pulse2-inventory-server.log'
    defaults = {'main': {'disable': 0},
                'database': {'dbdriver': 'mysql',
                             'dbhost': 'localhost',
                             'dbname': 'inventory',
                             'dbuser': 'mmc',
                             'dbpasswd': 'mmc'},
                'computers': {},
                'expert_mode': {},
                'graph': {}}

class LaunchersConfig(LoggingConfig):
    path = 'pulse2/launchers/launchers.ini'
    log_path = 'pulse2-launchers.log'
    defaults = {'wol': {'wol_path': '/usr/sbin/pulse2-wol'}}
    
class PackageServerConfig(LoggingConfig):
    path = 'pulse2/package-server/package-server.ini'
    log_path = 'pulse2-package-server.log'
    defaults = {'main': {'host': '0.0.0.0'}}

class SchedulerConfig(LoggingConfig):
    path = 'pulse2/scheduler/scheduler.ini'
    log_path = 'pulse2-scheduler.log'
    defaults = {'scheduler': {'id': 'scheduler_01'},
                'database': {'dbdriver': 'mysql',
                             'dbhost': 'localhost',
                             'dbname': 'msc',
                             'dbuser': 'mmc',
                             'dbpasswd': 'mmc'},
                'computer': {},
                'expert_mode': {},
                'graph': {}}

class ImagingServerConfig(LoggingConfig):
    path = 'pulse2/imaging-server/imaging-server.ini'
    log_path = 'pulse2-imaging-server.log'

    defaults = {'main': {},
                'daemon': {},
                'hooks': {}}

class SetupApp(object):
    defaults = {'imaging.service.enable': True,
                'inventory.service.enable': True,
                'package.service.enable': True}

    def __init__(self, datadir, confdir, batch=False):
        self.config = {}
        self.datadir = datadir
        self.confdir = confdir
        self.batch = batch

        # Check if we run as root
        if os.getuid()<>0:
            log.error("Please run this application as root")
            sys.exit(2)

        # Check datadir contains sql snippets
        self.sqldir = os.path.join(datadir, 'sql')
        if not os.path.isdir(self.sqldir):
            log.error('Can not find SQL snippets in %s' % self.sqldir)

        # Get db modules list
        self.dbmodules = [ m for m in os.listdir(self.sqldir) 
                           if os.path.isdir(os.path.join(self.sqldir, m)) ]

        # Load conf files, if existing
        # self.confs will contain path->ConfigParser objects dictionary
        # path is relative to confdir, as in confpaths list above
        self.confs = {}
        for clsname in Pulse2ConfigParser.clsnames:
            cls = globals()[clsname]
            self.confs[cls.path] = cls(self.confdir)

        # Creates Services objects
        self.services = []
        distro_handler = get_distro_handler()
        for clsname in Service.clsnames:
            cls = globals()[clsname]
            self.services.append(cls(distro_handler, self.config))

    def read_opt(self, name, default):
        if self.batch:
            return default
        else:
            return read_opt(name, default)
    
    def read_bool(self, name, default):
        if self.batch:
            return default
        else:
            return read_bool(name, default)

    def read_passwd(self, name, default=None):
        if self.batch:
            if default is not None:
                return default
            else:
                return gen_passwd()
        else:
            return read_passwd(name)

    def load_defaults(self):
        """ Load default values from config files objects
        Values are set from existing config files or default values in *Config classes.

        Note 1: db admin credentials are not stored in any file, except host.
        Note 2: current version does not support diffenriated db host or credentials. All 
          db must be on the same host. Default value are taken from plugins/pulse2.ini file.
        """
        self.defaults['ldapurl'] = self.confs['plugins/base.ini'].get('ldap', 'ldapurl')
        self.defaults['ldapbasedn'] = self.confs['plugins/base.ini'].get('ldap', 'basedn')        
        self.defaults['ldapadmindn'] = self.confs['plugins/base.ini'].get('ldap', 'rootname')
        self.defaults['ldappasswd'] = self.confs['plugins/base.ini'].get('ldap', 'password')

        self.defaults['dbhost'] = self.confs['plugins/pulse2.ini'].get('database', 'dbhost')
        self.defaults['dbadminuser'] = 'root'
        self.defaults['dbadminpasswd'] = ''
        self.defaults['dbuser'] = self.confs['plugins/pulse2.ini'].get('database', 'dbuser')
        passwd = self.confs['plugins/pulse2.ini'].get('database', 'dbpasswd')
        if passwd==PluginsPulse2Config.defaults['database']['dbpasswd']:
            # If passwd in config file is the default (weak) one, prefer generating a random one
            self.defaults['dbpasswd'] = gen_passwd()
        else:
            self.defaults['dbpasswd'] = self.confs['plugins/pulse2.ini'].get('database', 'dbpasswd')

        self.defaults['wol'] = self.confs['pulse2/launchers/launchers.ini'].get('wol', 'wol_path')

    def read_config(self):
        """ Read some global config values
        """
        self.config['inventory.service.enable'] = self.read_bool('Enable inventory server', 
                                                                 self.defaults['inventory.service.enable'])
        self.config['imaging.service.enable'] = self.read_bool('Enable imaging server', 
                                                               self.defaults['imaging.service.enable'])
        self.config['package.service.enable'] = self.read_bool('Enable package server (proxy)', 
                                                               self.defaults['package.service.enable'])

    def init_ldap(self):
        invalids = ['ldapurl', 'ldapbasedn', 'ldapadmindn', 'ldappasswd']
        while len(invalids):
            if 'ldapurl' in invalids:
                self.config['ldapurl'] = self.read_opt('LDAP uri', self.defaults['ldapurl'])
            if 'ldapbasedn' in invalids:
                self.config['ldapbasedn'] = self.read_opt('LDAP base DN', self.defaults['ldapbasedn'])
            if 'ldapadmindn' in invalids:
                self.config['ldapadmindn'] = self.read_opt('LDAP admin DN', self.defaults['ldapadmindn'])
            if 'ldappasswd' in invalids:
                self.config['ldappasswd'] = self.read_passwd('LDAP admin password', self.defaults['ldappasswd'])

            # Check parameters
            conn = ldap.initialize(self.config['ldapurl'])
            try:
                invalids = []
                conn.simple_bind_s(self.config['ldapadmindn'], self.config['ldappasswd'])
            except ldap.INVALID_CREDENTIALS, e:
                invalids += ['ldapbasedn', 'ldapadmindn', 'ldappasswd']
                log.error("Invalid credentials, check base DN, admin DN and password.")
                log.debug(str(e))
            except ldap.SERVER_DOWN, e:
                invalids += ['ldapurl']
                log.error("Incorrect server")
                log.debug(str(e))
            except ldap.UNWILLING_TO_PERFORM, e:
                invalids += ['ldappasswd']
                log.error("Empty password not supported")
                log.debug(str(e))
        log.info("Connection to LDAP succesfull.")

        # Check mmc schema is installed
        log.info("Check for MMC schema")
        (dn, schema) = ldap.schema.urlfetch(self.config['ldapurl'])
        if schema.get_obj(ldap.schema.ObjectClass, 'lmcUserObject') is None:
            log.error('MMC schema can not be found in LDAP directory.')
            log.error('Exiting...')
            sys.exit(1)

        # Populate base plugin conf file
        self.confs['plugins/base.ini'].set('ldap', 'ldapurl', self.config['ldapurl'])
        self.confs['plugins/base.ini'].set('ldap', 'basedn', self.config['ldapbasedn'])
        self.confs['plugins/base.ini'].set('ldap', 'rootname', self.config['ldapadmindn'])
        self.confs['plugins/base.ini'].set('ldap', 'password', self.config['ldappasswd'])
        
    def init_db(self):
        """ Create databases and associated schemas
        """
        invalid = True
        while invalid:
            # Get DB connection informations
            self.config['dbhost'] = self.read_opt('Database host', self.defaults['dbhost'])
            self.config['dbadminuser'] = self.read_opt('Database admin user', self.defaults['dbadminuser'])
            self.config['dbadminpasswd'] = self.read_passwd('Database admin password', self.defaults['dbadminpasswd'])

            # Create connection to DB and check it
            url = 'mysql://%s:%s@%s/mysql' % (self.config['dbadminuser'],
                                              self.config['dbadminpasswd'],
                                              self.config['dbhost'])
            self.engine = sa.create_engine(url)
            try:
                conn = self.engine.connect()
                invalid = False
            except sa.exc.OperationalError, e:
                log.error(u"Impossible de se connecter à la base de données")
                log.debug(str(e))

        env = os.environ
        env['MYSQL_HOST'] = self.config['dbhost']
        env['MYSQL_USER'] = self.config['dbadminuser']
        env['MYSQL_PWD'] = self.config['dbadminpasswd']
        for module in self.dbmodules:
            log.debug("Init database for module %s" % module)
            env['MYSQL_BASE'] = module
            binpath = os.path.join(self.sqldir, module, 'install.sh')
            ret = call(binpath, env=env)
            if ret<>0:
                log.error('Can not initialize database for module: %s' % module)

        # Get DB user and password for all modules
        log.info("Setup db credentials")
        self.config['dbuser'] = self.defaults['dbuser']
        self.config['dbpasswd'] = self.defaults['dbpasswd']

        conn = self.engine.connect()

        hosts = ['localhost', '127.0.0.1']
        if self.config['dbhost'] not in hosts:
            # Distant DB, we don't know from where it is accessed...
            hosts.append('%')

        for host in hosts:
            try:
                # Do not know how to check if user exists, then try and catch
                conn.execute('CREATE USER %s@%s', self.config['dbuser'], host)
                log.info('Creates user %s@%s' % (self.config['dbuser'], host))
            except sa.exc.OperationalError, e:
                if e.orig[0]==1396:
                    # This error means 'user exists'
                    log.debug('User already exists: %s@%s' % (self.config['dbuser'], host))
                elif e.orig[0]==1044:
                    log.error('Access denied: please check user \'%s\'@\'%s\' has grant rights.' % (self.config['dbuser'], 
                                                                                                    self.config['dbhost']))
                    sys.exit(2)
                else:
                    raise e

            # Set password in DB
            log.info('Updating user password: \'%s\'@\'%s\'' % (self.config['dbuser'], host))
            conn.execute('SET PASSWORD FOR %s@%s = PASSWORD(%s)', self.config['dbuser'], host, self.config['dbpasswd'])

            # Grant rights in DB
            try:
                for module in self.dbmodules:
                    log.info('Grant rights on db %s' % module)
                    # Put db name without sqlalchemy quoting: it was surrounded by `''
                    conn.execute('GRANT ALL on `%s`.* to %%s@%%s' % module, self.config['dbuser'], host)
            except sa.exc.OperationalError, e:
                if e.orig[0]==1044:
                    log.error('Access denied: please check user \'%s\'@\'%s\' has grant rights.' % (self.config['dbuser'], 
                                                                                                    self.config['dbhost']))
                    sys.exit(2)
                else:
                    raise e

        conn.execute('FLUSH PRIVILEGES')
        conn.close()

        #
        # Set db user and password in conf files
        #
        
        # dyngroup db
        self.confs['plugins/dyngroup.ini'].set('database', 'dbhost', self.config['dbhost'])
        self.confs['plugins/dyngroup.ini'].set('database', 'dbuser', self.config['dbuser'])
        self.confs['plugins/dyngroup.ini'].set('database', 'dbpasswd', self.config['dbpasswd'])

        # imaging db
        self.confs['plugins/imaging.ini'].set('database', 'dbhost', self.config['dbhost'])
        self.confs['plugins/imaging.ini'].set('database', 'dbuser', self.config['dbuser'])
        self.confs['plugins/imaging.ini'].set('database', 'dbpasswd', self.config['dbpasswd'])

        # inventory db (plugin)
        self.confs['plugins/inventory.ini']\
            .set('inventory', 'dbhost', self.config['dbhost'])
        self.confs['plugins/inventory.ini']\
            .set('inventory', 'dbuser', self.config['dbuser'])
        self.confs['plugins/inventory.ini']\
            .set('inventory', 'dbpasswd', self.config['dbpasswd'])

        # inventory db (server)
        self.confs['pulse2/inventory-server/inventory-server.ini']\
            .set('database', 'dbhost', self.config['dbhost'])
        self.confs['pulse2/inventory-server/inventory-server.ini']\
            .set('database', 'dbuser', self.config['dbuser'])
        self.confs['pulse2/inventory-server/inventory-server.ini']\
            .set('database', 'dbpasswd', self.config['dbpasswd'])

        # msc db (plugin)
        self.confs['plugins/msc.ini'].set('msc', 'dbhost', self.config['dbhost'])
        self.confs['plugins/msc.ini'].set('msc', 'dbuser', self.config['dbuser'])
        self.confs['plugins/msc.ini'].set('msc', 'dbpasswd', self.config['dbpasswd'])        
        
        # msc db (scheduler)
        self.confs['pulse2/scheduler/scheduler.ini']\
            .set('database', 'dbhost', self.config['dbhost'])
        self.confs['pulse2/scheduler/scheduler.ini']\
            .set('database', 'dbuser', self.config['dbuser'])
        self.confs['pulse2/scheduler/scheduler.ini']\
            .set('database', 'dbpasswd', self.config['dbpasswd'])

        # pulse2
        self.confs['plugins/pulse2.ini'].set('database', 'dbhost', self.config['dbhost'])
        self.confs['plugins/pulse2.ini'].set('database', 'dbuser', self.config['dbuser'])
        self.confs['plugins/pulse2.ini'].set('database', 'dbpasswd', self.config['dbpasswd'])

    def init_misc(self):
        # Choose glpi or inventory backend, and check config files coherency
        # TODO: ask for the user. For the moment, choose inventory
        self.confs['plugins/glpi.ini'].set('main', 'disable', 1)
        self.confs['plugins/inventory.ini'].set('main', 'disable', 0)
        self.confs['plugins/base.ini'].set('computers', 'method', 'inventory')
        
        # Ensure various dirs are created
        for path in [ self.confs['plugins/base.ini'].get('backup-tools', 'destpath'),
                      self.confs['plugins/msc.ini'].get('msc', 'qactionpath'),
                      self.confs['plugins/msc.ini'].get('msc', 'repopath'),
                      LoggingConfig.log_dir ]:
            if not os.path.isdir(path):
                log.info("Creating directory: %s" % path)
                os.makedirs(path)

        # Check wol tool path
        wol_path_ok = False
        while not wol_path_ok:
            wol_path = self.read_opt('Wake-on-lan tool path', self.defaults['wol'])
            self.confs['pulse2/launchers/launchers.ini'].set('wol', 'wol_path', wol_path)
            if os.path.exists(wol_path):
                wol_path_ok = True
            else:
                log.error('Can not find %s' % wol_path)

        # Check root user has a DSA key
        log.info('Check for root user DSA key pair')
        dsa_key_path = '/root/.ssh/id_dsa'
        if not os.path.exists(dsa_key_path):
            log.info('Creating a DSA key pair for user root')
            ret = call("/usr/bin/ssh-keygen -t dsa -N '' -f %s" % dsa_key_path, shell=True)
            if ret<>0:
                log.error('Can not create DSA key pair for user root')
                sys.exit(1)

        # Update services
        for srv in self.services:
            srv.update_rc()

    def restart_services(self):
        for srv in self.services:
            srv.restart()
                
    def commit(self):
        """ Write down all config files
        """
        for (path, conf) in self.confs.iteritems():
            conf.commit()

    def run(self):
        """ Run setup 
        """
        log.info("Load defaults values from existing config")
        self.load_defaults()
        self.read_config()

        log.info("Run setup")
        self.init_db()
        self.init_ldap()
        self.init_misc()
        self.commit()

        self.restart_services()

if __name__ == '__main__':
    parser = OptionParser()
    parser.add_option("-d", "--debug", action="store_true", dest="debug", default=False,
                      help="Print debug messages")
    parser.add_option("-b", "--batch", action="store_true", dest="batch", default=False,
                      help="Do not ask any question")
    parser.add_option("--pkgdatadir", action="store", dest="pkgdatadir", default='/usr/share/pulse2',
                      help="Path to pulse2 datadir (default: /usr/share/pulse2)")
    parser.add_option("--confdir", action="store", dest="confdir", default='/etc/mmc',
                      help="Path to pulse2 conf dir (default: /etc/mmc)")

    # Parse and analyse args
    (options, args) = parser.parse_args()
    if options.debug:
        level = logging.DEBUG
    else:
        level = logging.INFO

    # Init logger
    format = '%(levelname)-8s - %(message)s'
    logging.basicConfig(level=level, format=format)

    # Run the setup app
    app = SetupApp(datadir=options.pkgdatadir, confdir=options.confdir, batch=options.batch)
    app.run()

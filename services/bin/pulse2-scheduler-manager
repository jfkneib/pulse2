#!/usr/bin/python
#
# -*- coding: utf-8; -*-
#
# (c) 2007-2008 Mandriva, http://www.mandriva.com/
#
# $Id$
#
# This file is part of Pulse 2, http://pulse2.mandriva.org
#
# Pulse 2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Pulse 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pulse 2; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

# Big modules
import os
import os.path
import sys
import getopt
import ConfigParser
import re
import logging
import logging.config
import optparse
import signal
import time
import errno

time_to_wait = 2 # first stage: check of it is alive / dead after having being run /stopped for time_to_wait seconds
check_count = 5 # second stage: attempts to obtain a good result (check_count tries) to a XMLRPC call

from pulse2.scheduler.config import SchedulerConfig

def start_scheduler(config):
    """
    daemonize a scheduler
    """
    logger = logging.getLogger()
    name = config.name

    logger.info('daemonization started: scheduler %s' % name)

    pid_path = config.pid_path
    if not os.path.isdir(pid_path):
        os.makedirs(pid_path)

    pid = get_pidfile(config)
    if pid:
        if pid_is_alive(pid):
            logger.error('failed to start scheduler "%s": seems to be running under pid %d' % (name, pid))
            print 'failed to start scheduler "%s": seems to be running under pid %d' % (name, pid)
            return False
        else:
            clear_pidfile(config)
            logger.error('while starting scheduler "%s": clearing old pid file (pid was %d)' % (name, pid))

    # as a scheduler itself do not fork(), fork is done here
    # do the UNIX double-fork magic, see Stevens' "Advanced
    # Programming in the UNIX Environment" for details (ISBN 0201563177)
    try:
        pid = os.fork()
        if pid > 0:
            # first parent stays alive
            # let's check if it is realy alive
            # check is done in two stages:

            # let's do the first stage
            time.sleep(time_to_wait)
            pid = get_pidfile(config)
            if not pid_is_alive(pid): # os.WNOHANG make os.waitpid() to return (0, 0) if child is alive
                logger.error('daemonization part #2 failed: scheduler "%s" died in less than %d seconds' % (name, time_to_wait))
                clear_pidfile(config)
                return False

            # TODO: implement second stage here !
            return True
    except OSError, e:
        logger.error('daemonization part #1 failed: %d (%s)' % (e.errno, e.strerror))
        print >>sys.stderr, "daemonization part #1 failed: %d (%s)" % (e.errno, e.strerror)
        sys.exit(1)

    # decouple from parent environment
    os.close(sys.stdin.fileno())
    os.close(sys.stdout.fileno())
    os.close(sys.stderr.fileno())
    os.chdir("/")
    os.setsid()

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            logger.info('daemonization succedeed: "%s", pid %d' % (name, pid) ) # exit from second parent, print eventual PID before
            set_pidfile(config, pid) # records the PID from here, as it is the only place where we know it
            sys.exit(0)
    except OSError, e:
        logger.error('daemonization part #2 failed: %d (%s)' % (e.errno, e.strerror))
        sys.exit(1)

    # drop privs
    os.seteuid(0)
    os.setegid(0)
    os.setgid(config.daemon_group)
    os.setuid(config.daemon_user)

    scheduler_path = config.scheduler_path
    logger.info('daemonization ended: switching to %s' % [scheduler_path])
    os.execv(scheduler_path, (scheduler_path,))

def stop_scheduler(config):
    name = config.name
    logger = logging.getLogger()
    os.seteuid(0)
    os.setegid(0)

    pid = get_pidfile(config)
    if pid:
        if pid_is_alive(pid):
            logger.info('attempt to kill scheduler "%s" (pid %d)' % (name, pid))
            kill_pid(pid, signal.SIGTERM) # TODO: check that kill was successful
            logger.info('scheduler "%s" killed using SIGTERM' % name)
            clear_pidfile(config)
            return True
        else:
            clear_pidfile(config)
            return False
    else:
        clear_pidfile(config)
        return False

def clear_pidfile(config):
    os.setegid(0)
    os.seteuid(0)
    pid_file = os.path.join(config.pid_path, '%s.pid' % config.name)
    if os.path.isfile(pid_file):
        os.unlink(pid_file)
    os.setegid(config.daemon_group)
    os.seteuid(config.daemon_user)

def set_pidfile(config, pid):
    os.setegid(0)
    os.seteuid(0)
    pid_path = config.pid_path
    pid_file = os.path.join(config.pid_path, '%s.pid' % config.name)
    if not os.path.isdir(pid_path):
        os.makedirs(pid_path)
    os.system("echo %d > %s" % (pid, pid_file))
    os.setegid(config.daemon_group)
    os.seteuid(config.daemon_user)

def pid_is_alive(pid):
    return kill_pid(pid, 0)

def kill_pid(pid, signal):
    os.setegid(0)
    os.seteuid(0)
    try:
        os.kill(pid, signal)
    except OSError, err:
        if err.errno == errno.ESRCH:
            os.setegid(config.daemon_group)
            os.seteuid(config.daemon_user)
            return False
        elif err.errno == errno.EPERM: # WTF ? I *am* root, am I ?
            os.setegid(config.daemon_group)
            os.seteuid(config.daemon_user)
            return True
        else:
            os.setegid(config.daemon_group)
            os.seteuid(config.daemon_user)
            return False
    else:
        os.setegid(config.daemon_group)
        os.seteuid(config.daemon_user)
        return True

def get_pidfile(config):
    os.setegid(0)
    os.seteuid(0)
    name = config.name
    pid_file = os.path.join(config.pid_path, '%s.pid' % name)
    if not os.path.isfile(pid_file):
        os.setegid(config.daemon_group)
        os.seteuid(config.daemon_user)
        return False
    f = open(pid_file)
    for line in f:
        try:
            ret = int(line)
            f.close()
            os.setegid(config.daemon_group)
            os.seteuid(config.daemon_user)
            return ret
        except ValueError:
            pass
    os.setegid(config.daemon_group)
    os.seteuid(config.daemon_user)
    return False

if __name__ == "__main__":
    parser = optparse.OptionParser()
    parser.add_option("-c", "--config-file", help='path to the config file', default='/etc/mmc/pulse2/scheduler/scheduler.ini')
    parser.add_option("-o", "--id", help='id of this scheduler')
    (options, args) = parser.parse_args()

    if not os.path.exists(options.config_file):
        print "Config file '%s' does not exist." % options.config_file
        sys.exit(1)

    if len(args)!=1:
        print "command is missing"
        sys.exit(2)

    # Load configuration file
    config = SchedulerConfig()
    logging.config.fileConfig(config_file)
    config.setup(options.config_file)

    # Set umask and effective UID and GID values
    os.umask(config.umask)
    os.setegid(config.daemon_group)
    os.seteuid(config.daemon_user)

    # Try to create the default log directory
    LOGDIR = '/var/log/mmc'
    if not os.path.exists(LOGDIR):
        try:
            os.mkdir(LOGDIR)
        except:
            # Maybe we are not root, so it may not be a problem if the mkdir
            # failed
            pass
    logger = logging.getLogger()

    if args[0] == "start":
        logger.info('Starting Pulse2 Scheduler')
        print('Starting Pulse2 Scheduler:')
        if start_scheduler(config):
            logger.info('Scheduler started')
            print('OK')
        else:
            logger.warn('Failed to start scheduler')
            print('FAILED')
    elif args[0] == "stop":
        logger.info('stopping Pulse2 Scheduler')
        print('Stopping Pulse2 Scheduler:')
        if stop_scheduler(config):
            logger.info('Scheduler stopped')
            print('OK')
        else:
            logger.warn('Failed to stop scheduler')
            print('FAILED')


